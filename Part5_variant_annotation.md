# Variant annotation

## Introduction

This section of the tutorial deals with filtering variants, comparing variants, and annotating variants.  It assumes you have completed Parts 2, 4a, and 4b so that you have 3 VCF files from each of the three variant calling approaches in the directory structure established in the tutorial. 

Steps here will use the following software packages:

- []()
- []()

Each major step below has an associated bash script tailored to the UConn CBC Xanadu cluster with appropriate headers for the [Slurm](https://slurm.schedmd.com/documentation.html) job scheduler. The code can easily be modified to run interactively, or in other contexts. 

## Contents
  
1.    [ Motivation ](#Motivation)
2.    [ Update your working directory ](#Update-your-working-directory)  

## Motivation

Once you call variants on a given set of samples, you face a couple of issues:

1. To varying degrees, most variant callers have high sensitivity, but low specificity, outputting many false positive results. Thus, depending on your application, raw variant sets may need to be filtered. 
2. You may want to compare variant sets generated by different callers, or with a set found in a database. Different variant callers, however, may output variants in slightly different ways due to the treatment of haplotype alleles and the ambiguity of representation inherent to some complex variants. In order to ensure apples-to-apples comparisons, you may need to normalize variant representation in your VCF file. 



## Update your working directory



## Variant filtering

There are two main approaches to dealing with the possibility of sequencing variation being artifactual. The most common is called __hard filtering__. In hard filtering, you face a binary choice. First set thresholds on some summary statistics describing a variant. If those thresholds are not met, exclude the variant from analysis. Most variant calling tools output a wide array of statistics that can be used for this purpose. As we saw in Part 2, these statistics are often found in the INFO field (column 8 of the VCF), but a key quantity is the variant quality (column 6 of the VCF, QUAL). The variant quality accounts for all the factors the variant caller uses to judge the evidence of variation in the site and summarizes it in a single phred-scaled quality score. The main weakness of this approach is that there is no threshold or combination of thresholds that perfectly discriminates true positives from true negatives. 

The second approach is to use a statistical model to incorporate the uncertainty in whether  variation at a site is real, and in the genotypes of individuals at that site. These approaches do not make binary decisions on variants or genotypes, but essentially average the results of downstream analyses over all possibilities, weighted by their probability. The main weakness of this approach (aside from tools not being available in every case) is that it is conditioned on the variant calling model being well calibrated. 

Which of these approaches you take will depend on the sensitivity of your analyses to the presence of false positives and false negatives, and whether or not tools are available to account for uncertainty. It has been shown that for some applications in population genetics, hard filtering can cause biases ([see Korneliussen et al.](https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-014-0356-4) for more). 

Here we will use a hard filtering approach. 

In this example, we'll use `bcftools` to set a simple threshold on the quality score. We could exclude all the low quality variants from the new file, but for this instance, we'll simply use the FILTER field (column 7 in the VCF) to flag them as either PASS or LowQual:

```bash
bcftools filter -s LowQual -e '%QUAL<20' ../variants_freebayes/chinesetrio_fb.vcf.gz | bgzip -c > fb_filter.vcf.gz
```
In this case `-s` means "soft filter", or set values in the FILTER field and leave all the variants in the file. `%QUAL<20` is our filtering threshold (see the `bcftools` documentation for how to specify other expressions). 

In the end we get results like this:

```bash
chr20	34398628	.	A	C	0	LowQual	AB=0;ABP=0;AC=0;AF=0;AN=6;AO=26;CIGAR=1X;DP=169;DPB=169;DPRA=0;EPP=43.4331;EPPR=3.07324;GTI=0;LEN=1;MEANALT=2;MQM=52.6538;MQMR=59.4203;NS=3;NUMALT=1;ODDS=50.5069;PAIRED=1;PAIREDR=1;PAO=0;PQA=0;PQR=0;PRO=0;QA=260;QR=4556;RO=138;RPL=2;RPP=43.4331;RPPR=4.01736;RPR=24;RUN=1;SAF=0;SAP=59.4686;SAR=26;SRF=113;SRP=124.865;SRR=25;TYPE=snp	GT:DP:AD:RO:QR:AO:QA:GL	0/0:65:50,15:50:1718:15:152:0,-5.78839,-141.074	0/0:62:51,10:51:1723:10:93:0,-10.0033,-146.776	0/0:42:37,1:37:1115:1:15:0,-10.0897,-99.0743
chr20	34399330	.	G	T	5725.11	PASS	AB=0.487603;ABP=3.17181;AC=5;AF=0.833333;AN=6;AO=216;CIGAR=1X;DP=280;DPB=280;DPRA=0;EPP=12.0581;EPPR=8.83536;GTI=0;LEN=1;MEANALT=1.33333;MQM=59.287;MQMR=60;NS=3;NUMALT=1;ODDS=44.2501;PAIRED=1;PAIREDR=1;PAO=0;PQA=0;PQR=0;PRO=0;QA=6932;QR=1912;RO=63;RPL=112;RPP=3.6537;RPPR=5.80219;RPR=104;RUN=1;SAF=79;SAP=36.829;SAR=137;SRF=20;SRP=21.2438;SRR=43;TYPE=snp	GT:DP:AD:RO:QR:AO:QA:GL	0/1:121:62,59:62:1897:59:1915:-135.887,0,-134.53	1/1:100:0,99:0:0:99:3068:-276.127,-29.802,0	1/1:59:1,58:1:15:58:1949:-174.125,-16.2608,0
```

___
scripts:
- []()

## Variant comparison

___
scripts:
- []()

## Variant annotation

___
scripts:
- []()


vcflib, vt, vcfeval (https://www.realtimegenomics.com/products/rtg-tools)
vgraph (https://github.com/bioinformed/vgraph)
bcftools normalize
https://github.com/Illumina/hap.py

?? how do we discuss annotation ?? 
?? how do we compare variant call sets ??

discussion of normalization:
https://genome.sph.umich.edu/wiki/Variant_Normalization


bcftools annotate does simple matching. does not account for complex alleles or incompatible representations. 

--dbsnp in haplotypecaller can accept a vcf file and annotate snps
